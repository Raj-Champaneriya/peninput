@page "/handwritten-notes"
@inject HandwrittenNotesService NotesService
@inject IJSRuntime JS
@implements IAsyncDisposable

<h3>Handwritten Notes</h3>

<input id="hw-note-title" type="text" @bind="title" placeholder="Note Title" />

<!-- üé® Color Picker -->
<label>Color:</label>
<input id="hw-note-color" type="color" @bind="selectedColor" bind:event="oninput" @oninput="ChangeColor" />

<canvas id="drawingCanvas" width="800" height="400" style="border:1px solid black;"></canvas>

<div>
    <button @onclick="NewNote">New</button>
    <button @onclick="ClearCanvas">Erase</button>
    <button @onclick="UndoCanvas">Undo</button>
    <button @onclick="RedoCanvas">Redo</button>
</div>

<h3>Saved Notes</h3>
<ul>
    @foreach (var note in notes)
    {
        <li @onclick="() => LoadNote(note)">
            <strong>@note.Title</strong>
            <span>(@note.CreatedAt)</span>
            <div>@(new MarkupString(note.SVGData))</div>
        </li>
    }
</ul>

@code {
    private string title = "Untitled Note";
    private List<HandwrittenNote> notes = new();
    private Guid? editingNoteId = null;
    private bool isAutoSaving = false;
    private CancellationTokenSource autoSaveCts = new();
    private DotNetObjectReference<HandwrittenNotes>? jsHelper;
    private bool isJsRegistered = false;
    private string selectedColor = "#000000"; // Default color (black)
    private bool isDisposed = false;

    protected override async Task OnInitializedAsync()
    {
        notes = await NotesService.GetNotesAsync();

    }

    private async Task ChangeColor(ChangeEventArgs e)
    {
        selectedColor = e.Value?.ToString() ?? "#000000";
        Console.WriteLine($"Selected Color: {selectedColor}"); // ‚úÖ Debug log to confirm selection
        await JS.InvokeVoidAsync("setDrawingColor", selectedColor);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !isJsRegistered && !isDisposed)
        {
            jsHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerBlazorAutoSave", jsHelper);
            await JS.InvokeVoidAsync("initializeCanvas");
            isJsRegistered = true;
        }
    }

    private async Task NewNote()
    {
        title = "Untitled Note";
        editingNoteId = null; // Mark as a new note
        await ClearCanvas();
        await JS.InvokeVoidAsync("initializeCanvas"); // Ensure JS knows about the canvas
    }

    private async Task LoadNote(HandwrittenNote note)
    {
        editingNoteId = note.Id; // Mark as an existing note
        title = note.Title;
        await JS.InvokeVoidAsync("loadSVGData", note.SVGData);
    }

    [JSInvokable("AutoSave")]
    public async Task AutoSave()
    {
        if (editingNoteId == null || isDisposed) return; // ‚úÖ Prevent auto-save if disposed

        Console.WriteLine("üîÑ Auto-saving note...");

        isAutoSaving = true;

        autoSaveCts?.Cancel();
        autoSaveCts = new CancellationTokenSource();
        var token = autoSaveCts.Token;
        try
        {
            await Task.Delay(1000, token); // ‚è≥ Delay auto-save to prevent unnecessary updates
            if (token.IsCancellationRequested) return;

            Console.WriteLine("üîÑ Auto-saving note...");

            string svgData = await JS.InvokeAsync<string>("getSVGData");

            // Update note in database without forcing re-render
            await NotesService.UpdateNoteAsync(editingNoteId.Value, title, svgData);

            // ‚úÖ Only update UI state if needed
            InvokeAsync(StateHasChanged);
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine("‚ö†Ô∏è AutoSave was cancelled");
        }
        finally
        {
            isAutoSaving = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        isDisposed = true; // ‚úÖ Prevent further JS calls

        if (jsHelper != null)
        {
            try
            {
                await JS.InvokeVoidAsync("unregisterBlazorAutoSave");
            }
            catch (JSDisconnectedException)
            {
                Console.WriteLine("‚ö†Ô∏è JSInterop call ignored due to disconnection.");
            }
            jsHelper.Dispose();
        }
    }

    private async Task SaveNote()
    {
        string svgData = await JS.InvokeAsync<string>("getSVGData");

        if (editingNoteId == null)
        {
            // Create a new note
            var newNote = new HandwrittenNote { Title = title, SVGData = svgData };
            await NotesService.AddNoteAsync(newNote);
            notes.Add(newNote);
            editingNoteId = newNote.Id; // Now it's being edited
        }
        else
        {
            // Update the existing note
            await NotesService.UpdateNoteAsync(editingNoteId.Value, title, svgData);
            var note = notes.FirstOrDefault(n => n.Id == editingNoteId);
            if (note != null)
            {
                note.Title = title;
                note.SVGData = svgData;
            }
        }
    }

    private async Task ClearCanvas()
    {
        await JS.InvokeVoidAsync("clearCanvas");
    }

    private async Task UndoCanvas() => await JS.InvokeVoidAsync("undoCanvas");
    private async Task RedoCanvas() => await JS.InvokeVoidAsync("redoCanvas");
}
